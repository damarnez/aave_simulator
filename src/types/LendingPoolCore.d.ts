/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
} from "ethers";
import {
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "@ethersproject/contracts";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";

interface LendingPoolCoreInterface extends ethers.utils.Interface {
  functions: {
    "CORE_REVISION()": FunctionFragment;
    "addressesProvider()": FunctionFragment;
    "lendingPoolAddress()": FunctionFragment;
    "reservesList(uint256)": FunctionFragment;
    "initialize(address)": FunctionFragment;
    "updateStateOnDeposit(address,address,uint256,bool)": FunctionFragment;
    "updateStateOnRedeem(address,address,uint256,bool)": FunctionFragment;
    "updateStateOnFlashLoan(address,uint256,uint256,uint256)": FunctionFragment;
    "updateStateOnBorrow(address,address,uint256,uint256,uint8)": FunctionFragment;
    "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)": FunctionFragment;
    "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)": FunctionFragment;
    "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)": FunctionFragment;
    "updateStateOnRebalance(address,address,uint256)": FunctionFragment;
    "setUserUseReserveAsCollateral(address,address,bool)": FunctionFragment;
    "transferToUser(address,address,uint256)": FunctionFragment;
    "transferToFeeCollectionAddress(address,address,uint256,address)": FunctionFragment;
    "liquidateFee(address,uint256,address)": FunctionFragment;
    "transferToReserve(address,address,uint256)": FunctionFragment;
    "getUserBasicReserveData(address,address)": FunctionFragment;
    "isUserAllowedToBorrowAtStable(address,address,uint256)": FunctionFragment;
    "getUserUnderlyingAssetBalance(address,address)": FunctionFragment;
    "getReserveInterestRateStrategyAddress(address)": FunctionFragment;
    "getReserveATokenAddress(address)": FunctionFragment;
    "getReserveAvailableLiquidity(address)": FunctionFragment;
    "getReserveTotalLiquidity(address)": FunctionFragment;
    "getReserveNormalizedIncome(address)": FunctionFragment;
    "getReserveTotalBorrows(address)": FunctionFragment;
    "getReserveTotalBorrowsStable(address)": FunctionFragment;
    "getReserveTotalBorrowsVariable(address)": FunctionFragment;
    "getReserveLiquidationThreshold(address)": FunctionFragment;
    "getReserveLiquidationBonus(address)": FunctionFragment;
    "getReserveCurrentVariableBorrowRate(address)": FunctionFragment;
    "getReserveCurrentStableBorrowRate(address)": FunctionFragment;
    "getReserveCurrentAverageStableBorrowRate(address)": FunctionFragment;
    "getReserveCurrentLiquidityRate(address)": FunctionFragment;
    "getReserveLiquidityCumulativeIndex(address)": FunctionFragment;
    "getReserveVariableBorrowsCumulativeIndex(address)": FunctionFragment;
    "getReserveConfiguration(address)": FunctionFragment;
    "getReserveDecimals(address)": FunctionFragment;
    "isReserveBorrowingEnabled(address)": FunctionFragment;
    "isReserveUsageAsCollateralEnabled(address)": FunctionFragment;
    "getReserveIsStableBorrowRateEnabled(address)": FunctionFragment;
    "getReserveIsActive(address)": FunctionFragment;
    "getReserveIsFreezed(address)": FunctionFragment;
    "getReserveLastUpdate(address)": FunctionFragment;
    "getReserveUtilizationRate(address)": FunctionFragment;
    "getReserves()": FunctionFragment;
    "isUserUseReserveAsCollateralEnabled(address,address)": FunctionFragment;
    "getUserOriginationFee(address,address)": FunctionFragment;
    "getUserCurrentBorrowRateMode(address,address)": FunctionFragment;
    "getUserCurrentStableBorrowRate(address,address)": FunctionFragment;
    "getUserBorrowBalances(address,address)": FunctionFragment;
    "getUserVariableBorrowCumulativeIndex(address,address)": FunctionFragment;
    "getUserLastUpdate(address,address)": FunctionFragment;
    "refreshConfiguration()": FunctionFragment;
    "initReserve(address,address,uint256,address)": FunctionFragment;
    "removeLastAddedReserve(address)": FunctionFragment;
    "setReserveInterestRateStrategyAddress(address,address)": FunctionFragment;
    "enableBorrowingOnReserve(address,bool)": FunctionFragment;
    "disableBorrowingOnReserve(address)": FunctionFragment;
    "enableReserveAsCollateral(address,uint256,uint256,uint256)": FunctionFragment;
    "disableReserveAsCollateral(address)": FunctionFragment;
    "enableReserveStableBorrowRate(address)": FunctionFragment;
    "disableReserveStableBorrowRate(address)": FunctionFragment;
    "activateReserve(address)": FunctionFragment;
    "deactivateReserve(address)": FunctionFragment;
    "freezeReserve(address)": FunctionFragment;
    "unfreezeReserve(address)": FunctionFragment;
    "setReserveBaseLTVasCollateral(address,uint256)": FunctionFragment;
    "setReserveLiquidationThreshold(address,uint256)": FunctionFragment;
    "setReserveLiquidationBonus(address,uint256)": FunctionFragment;
    "setReserveDecimals(address,uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "CORE_REVISION",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addressesProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lendingPoolAddress",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reservesList",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "initialize", values: [string]): string;
  encodeFunctionData(
    functionFragment: "updateStateOnDeposit",
    values: [string, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnRedeem",
    values: [string, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnFlashLoan",
    values: [string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnBorrow",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnRepay",
    values: [string, string, BigNumberish, BigNumberish, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnSwapRate",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnLiquidation",
    values: [
      string,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStateOnRebalance",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setUserUseReserveAsCollateral",
    values: [string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToUser",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToFeeCollectionAddress",
    values: [string, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateFee",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferToReserve",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserBasicReserveData",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "isUserAllowedToBorrowAtStable",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserUnderlyingAssetBalance",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveInterestRateStrategyAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveATokenAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveAvailableLiquidity",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveTotalLiquidity",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveNormalizedIncome",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveTotalBorrows",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveTotalBorrowsStable",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveTotalBorrowsVariable",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveLiquidationThreshold",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveLiquidationBonus",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveCurrentVariableBorrowRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveCurrentStableBorrowRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveCurrentAverageStableBorrowRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveCurrentLiquidityRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveLiquidityCumulativeIndex",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveVariableBorrowsCumulativeIndex",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveConfiguration",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveDecimals",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isReserveBorrowingEnabled",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isReserveUsageAsCollateralEnabled",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveIsStableBorrowRateEnabled",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveIsActive",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveIsFreezed",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveLastUpdate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserveUtilizationRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isUserUseReserveAsCollateralEnabled",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserOriginationFee",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserCurrentBorrowRateMode",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserCurrentStableBorrowRate",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserBorrowBalances",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserVariableBorrowCumulativeIndex",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserLastUpdate",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "refreshConfiguration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initReserve",
    values: [string, string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeLastAddedReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveInterestRateStrategyAddress",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "enableBorrowingOnReserve",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "disableBorrowingOnReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "enableReserveAsCollateral",
    values: [string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "disableReserveAsCollateral",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "enableReserveStableBorrowRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "disableReserveStableBorrowRate",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "activateReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "deactivateReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "freezeReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "unfreezeReserve",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveBaseLTVasCollateral",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveLiquidationThreshold",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveLiquidationBonus",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveDecimals",
    values: [string, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "CORE_REVISION",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addressesProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lendingPoolAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reservesList",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnDeposit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnRedeem",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnFlashLoan",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnBorrow",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnRepay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnSwapRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnLiquidation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateStateOnRebalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUserUseReserveAsCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToFeeCollectionAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "liquidateFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferToReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserBasicReserveData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUserAllowedToBorrowAtStable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserUnderlyingAssetBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveInterestRateStrategyAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveATokenAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveAvailableLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveTotalLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveNormalizedIncome",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveTotalBorrows",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveTotalBorrowsStable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveTotalBorrowsVariable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveLiquidationThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveLiquidationBonus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveCurrentVariableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveCurrentStableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveCurrentAverageStableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveCurrentLiquidityRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveLiquidityCumulativeIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveVariableBorrowsCumulativeIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveDecimals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isReserveBorrowingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isReserveUsageAsCollateralEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveIsStableBorrowRateEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveIsActive",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveIsFreezed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveLastUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserveUtilizationRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isUserUseReserveAsCollateralEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserOriginationFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserCurrentBorrowRateMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserCurrentStableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserBorrowBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserVariableBorrowCumulativeIndex",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserLastUpdate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refreshConfiguration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeLastAddedReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveInterestRateStrategyAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableBorrowingOnReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableBorrowingOnReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableReserveAsCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableReserveAsCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableReserveStableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "disableReserveStableBorrowRate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "activateReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deactivateReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "freezeReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unfreezeReserve",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveBaseLTVasCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveLiquidationThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveLiquidationBonus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveDecimals",
    data: BytesLike
  ): Result;

  events: {
    "ReserveDataUpdated(address,uint256,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "ReserveUpdated(address,uint256,uint256,uint256,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ReserveDataUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReserveUpdated"): EventFragment;
}

export class LendingPoolCore extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  on(event: EventFilter | string, listener: Listener): this;
  once(event: EventFilter | string, listener: Listener): this;
  addListener(eventName: EventFilter | string, listener: Listener): this;
  removeAllListeners(eventName: EventFilter | string): this;
  removeListener(eventName: any, listener: Listener): this;

  interface: LendingPoolCoreInterface;

  functions: {
    CORE_REVISION(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    "CORE_REVISION()"(
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    addressesProvider(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "addressesProvider()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    lendingPoolAddress(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "lendingPoolAddress()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    reservesList(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    "reservesList(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    initialize(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    "initialize(address)"(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    updateStateOnDeposit(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    "updateStateOnDeposit(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    updateStateOnRedeem(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    "updateStateOnRedeem(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    updateStateOnFlashLoan(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    "updateStateOnFlashLoan(address,uint256,uint256,uint256)"(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    updateStateOnBorrow(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    "updateStateOnBorrow(address,address,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnRepay(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)"(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnSwapRate(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    updateStateOnLiquidation(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)"(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    updateStateOnRebalance(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    "updateStateOnRebalance(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    setUserUseReserveAsCollateral(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    "setUserUseReserveAsCollateral(address,address,bool)"(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    transferToUser(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    "transferToUser(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToFeeCollectionAddress(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToFeeCollectionAddress(address,address,uint256,address)"(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    liquidateFee(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    "liquidateFee(address,uint256,address)"(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToReserve(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToReserve(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<ContractTransaction>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    getUserBasicReserveData(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    "getUserBasicReserveData(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    isUserAllowedToBorrowAtStable(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    "isUserAllowedToBorrowAtStable(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    getUserUnderlyingAssetBalance(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    "getUserUnderlyingAssetBalance(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    getReserveInterestRateStrategyAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    "getReserveInterestRateStrategyAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    getReserveATokenAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    "getReserveATokenAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: string;
    }>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    getReserveAvailableLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    "getReserveAvailableLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    getReserveTotalLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    "getReserveTotalLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    getReserveNormalizedIncome(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    "getReserveNormalizedIncome(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    getReserveTotalBorrows(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    "getReserveTotalBorrows(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    getReserveTotalBorrowsStable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    "getReserveTotalBorrowsStable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    getReserveTotalBorrowsVariable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    "getReserveTotalBorrowsVariable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    getReserveLiquidationThreshold(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    "getReserveLiquidationThreshold(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    getReserveLiquidationBonus(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    "getReserveLiquidationBonus(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    getReserveCurrentVariableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    "getReserveCurrentVariableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    getReserveCurrentStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    "getReserveCurrentStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    getReserveCurrentAverageStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    "getReserveCurrentAverageStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    getReserveCurrentLiquidityRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    "getReserveCurrentLiquidityRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    getReserveLiquidityCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    "getReserveLiquidityCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    getReserveVariableBorrowsCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    "getReserveVariableBorrowsCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    getReserveConfiguration(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    "getReserveConfiguration(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    getReserveDecimals(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    "getReserveDecimals(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    isReserveBorrowingEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    "isReserveBorrowingEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    isReserveUsageAsCollateralEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    "isReserveUsageAsCollateralEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    getReserveIsStableBorrowRateEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    "getReserveIsStableBorrowRateEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    getReserveIsActive(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    "getReserveIsActive(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    getReserveIsFreezed(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    "getReserveIsFreezed(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    getReserveLastUpdate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      timestamp: number;
      0: number;
    }>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    "getReserveLastUpdate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      timestamp: number;
      0: number;
    }>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    getReserveUtilizationRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    "getReserveUtilizationRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * @returns the array of reserves configured on the core*
     */
    getReserves(
      overrides?: CallOverrides
    ): Promise<{
      0: string[];
    }>;

    /**
     * @returns the array of reserves configured on the core*
     */
    "getReserves()"(
      overrides?: CallOverrides
    ): Promise<{
      0: string[];
    }>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    isUserUseReserveAsCollateralEnabled(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    "isUserUseReserveAsCollateralEnabled(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: boolean;
    }>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    getUserOriginationFee(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    "getUserOriginationFee(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    getUserCurrentBorrowRateMode(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    "getUserCurrentBorrowRateMode(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
    }>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    getUserCurrentStableBorrowRate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    "getUserCurrentStableBorrowRate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    getUserBorrowBalances(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
    }>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    "getUserBorrowBalances(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
    }>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserVariableBorrowCumulativeIndex(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserVariableBorrowCumulativeIndex(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
    }>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserLastUpdate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      timestamp: BigNumber;
      0: BigNumber;
    }>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserLastUpdate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      timestamp: BigNumber;
      0: BigNumber;
    }>;

    /**
     * updates the lending pool core configuration*
     */
    refreshConfiguration(overrides?: Overrides): Promise<ContractTransaction>;

    /**
     * updates the lending pool core configuration*
     */
    "refreshConfiguration()"(
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    initReserve(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "initReserve(address,address,uint256,address)"(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    removeLastAddedReserve(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    "removeLastAddedReserve(address)"(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    setReserveInterestRateStrategyAddress(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "setReserveInterestRateStrategyAddress(address,address)"(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    enableBorrowingOnReserve(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    "enableBorrowingOnReserve(address,bool)"(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    disableBorrowingOnReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableBorrowingOnReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    enableReserveAsCollateral(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "enableReserveAsCollateral(address,uint256,uint256,uint256)"(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    disableReserveAsCollateral(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "disableReserveAsCollateral(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    enableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "enableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    disableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    activateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    "activateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    deactivateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    "deactivateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    freezeReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    "freezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    unfreezeReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    "unfreezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    setReserveBaseLTVasCollateral(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    "setReserveBaseLTVasCollateral(address,uint256)"(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    setReserveLiquidationThreshold(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    "setReserveLiquidationThreshold(address,uint256)"(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    setReserveLiquidationBonus(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    "setReserveLiquidationBonus(address,uint256)"(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    setReserveDecimals(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    "setReserveDecimals(address,uint256)"(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<ContractTransaction>;
  };

  CORE_REVISION(overrides?: CallOverrides): Promise<BigNumber>;

  "CORE_REVISION()"(overrides?: CallOverrides): Promise<BigNumber>;

  addressesProvider(overrides?: CallOverrides): Promise<string>;

  "addressesProvider()"(overrides?: CallOverrides): Promise<string>;

  lendingPoolAddress(overrides?: CallOverrides): Promise<string>;

  "lendingPoolAddress()"(overrides?: CallOverrides): Promise<string>;

  reservesList(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  "reservesList(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * initializes the Core contract, invoked upon registration on the AddressesProvider
   * @param _addressesProvider the addressesProvider contract*
   */
  initialize(
    _addressesProvider: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * initializes the Core contract, invoked upon registration on the AddressesProvider
   * @param _addressesProvider the addressesProvider contract*
   */
  "initialize(address)"(
    _addressesProvider: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a deposit action
   * @param _amount the amount being deposited
   * @param _isFirstDeposit true if the user is depositing for the first time*
   * @param _reserve the address of the reserve in which the deposit is happening
   * @param _user the address of the the user depositing
   */
  updateStateOnDeposit(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    _isFirstDeposit: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a deposit action
   * @param _amount the amount being deposited
   * @param _isFirstDeposit true if the user is depositing for the first time*
   * @param _reserve the address of the reserve in which the deposit is happening
   * @param _user the address of the the user depositing
   */
  "updateStateOnDeposit(address,address,uint256,bool)"(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    _isFirstDeposit: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a redeem action
   * @param _amountRedeemed the amount being redeemed
   * @param _reserve the address of the reserve in which the redeem is happening
   * @param _user the address of the the user redeeming
   * @param _userRedeemedEverything true if the user is redeeming everything*
   */
  updateStateOnRedeem(
    _reserve: string,
    _user: string,
    _amountRedeemed: BigNumberish,
    _userRedeemedEverything: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a redeem action
   * @param _amountRedeemed the amount being redeemed
   * @param _reserve the address of the reserve in which the redeem is happening
   * @param _user the address of the the user redeeming
   * @param _userRedeemedEverything true if the user is redeeming everything*
   */
  "updateStateOnRedeem(address,address,uint256,bool)"(
    _reserve: string,
    _user: string,
    _amountRedeemed: BigNumberish,
    _userRedeemedEverything: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a flashloan action
   * @param _income the income of the protocol as a result of the action*
   * @param _reserve the address of the reserve in which the flashloan is happening
   */
  updateStateOnFlashLoan(
    _reserve: string,
    _availableLiquidityBefore: BigNumberish,
    _income: BigNumberish,
    _protocolFee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a result of a flashloan action
   * @param _income the income of the protocol as a result of the action*
   * @param _reserve the address of the reserve in which the flashloan is happening
   */
  "updateStateOnFlashLoan(address,uint256,uint256,uint256)"(
    _reserve: string,
    _availableLiquidityBefore: BigNumberish,
    _income: BigNumberish,
    _protocolFee: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a borrow action.
   * @param _amountBorrowed the new amount borrowed
   * @param _borrowFee the fee on the amount borrowed
   * @param _rateMode the borrow rate mode (stable, variable)
   * @param _reserve the address of the reserve on which the user is borrowing
   * @param _user the address of the borrower
   * @returns the new borrow rate for the user*
   */
  updateStateOnBorrow(
    _reserve: string,
    _user: string,
    _amountBorrowed: BigNumberish,
    _borrowFee: BigNumberish,
    _rateMode: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a borrow action.
   * @param _amountBorrowed the new amount borrowed
   * @param _borrowFee the fee on the amount borrowed
   * @param _rateMode the borrow rate mode (stable, variable)
   * @param _reserve the address of the reserve on which the user is borrowing
   * @param _user the address of the borrower
   * @returns the new borrow rate for the user*
   */
  "updateStateOnBorrow(address,address,uint256,uint256,uint8)"(
    _reserve: string,
    _user: string,
    _amountBorrowed: BigNumberish,
    _borrowFee: BigNumberish,
    _rateMode: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a repay action.
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _originationFeeRepaid the fee on the amount that is being repaid
   * @param _paybackAmountMinusFees the amount being paid back minus fees
   * @param _repaidWholeLoan true if the user is repaying the whole loan*
   * @param _reserve the address of the reserve on which the user is repaying
   * @param _user the address of the borrower
   */
  updateStateOnRepay(
    _reserve: string,
    _user: string,
    _paybackAmountMinusFees: BigNumberish,
    _originationFeeRepaid: BigNumberish,
    _balanceIncrease: BigNumberish,
    _repaidWholeLoan: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a repay action.
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _originationFeeRepaid the fee on the amount that is being repaid
   * @param _paybackAmountMinusFees the amount being paid back minus fees
   * @param _repaidWholeLoan true if the user is repaying the whole loan*
   * @param _reserve the address of the reserve on which the user is repaying
   * @param _user the address of the borrower
   */
  "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)"(
    _reserve: string,
    _user: string,
    _paybackAmountMinusFees: BigNumberish,
    _originationFeeRepaid: BigNumberish,
    _balanceIncrease: BigNumberish,
    _repaidWholeLoan: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a swap rate action.
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
   * @param _currentRateMode the current interest rate mode for the user*
   * @param _principalBorrowBalance the amount borrowed by the user
   * @param _reserve the address of the reserve on which the user is repaying
   * @param _user the address of the borrower
   */
  updateStateOnSwapRate(
    _reserve: string,
    _user: string,
    _principalBorrowBalance: BigNumberish,
    _compoundedBorrowBalance: BigNumberish,
    _balanceIncrease: BigNumberish,
    _currentRateMode: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a swap rate action.
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
   * @param _currentRateMode the current interest rate mode for the user*
   * @param _principalBorrowBalance the amount borrowed by the user
   * @param _reserve the address of the reserve on which the user is repaying
   * @param _user the address of the borrower
   */
  "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)"(
    _reserve: string,
    _user: string,
    _principalBorrowBalance: BigNumberish,
    _compoundedBorrowBalance: BigNumberish,
    _balanceIncrease: BigNumberish,
    _currentRateMode: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a liquidation action.
   * @param _amountToLiquidate the amount being repaid by the liquidator
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _collateralReserve the address of the collateral reserve that is being liquidated
   * @param _collateralToLiquidate the amount of collateral being liquidated
   * @param _feeLiquidated the amount of origination fee being liquidated
   * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
   * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
   * @param _principalReserve the address of the principal reserve that is being repaid
   * @param _user the address of the borrower
   */
  updateStateOnLiquidation(
    _principalReserve: string,
    _collateralReserve: string,
    _user: string,
    _amountToLiquidate: BigNumberish,
    _collateralToLiquidate: BigNumberish,
    _feeLiquidated: BigNumberish,
    _liquidatedCollateralForFee: BigNumberish,
    _balanceIncrease: BigNumberish,
    _liquidatorReceivesAToken: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a liquidation action.
   * @param _amountToLiquidate the amount being repaid by the liquidator
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _collateralReserve the address of the collateral reserve that is being liquidated
   * @param _collateralToLiquidate the amount of collateral being liquidated
   * @param _feeLiquidated the amount of origination fee being liquidated
   * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
   * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
   * @param _principalReserve the address of the principal reserve that is being repaid
   * @param _user the address of the borrower
   */
  "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)"(
    _principalReserve: string,
    _collateralReserve: string,
    _user: string,
    _amountToLiquidate: BigNumberish,
    _collateralToLiquidate: BigNumberish,
    _feeLiquidated: BigNumberish,
    _liquidatedCollateralForFee: BigNumberish,
    _balanceIncrease: BigNumberish,
    _liquidatorReceivesAToken: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a stable rate rebalance
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _reserve the address of the principal reserve where the user borrowed
   * @param _user the address of the borrower
   * @returns the new stable rate for the user*
   */
  updateStateOnRebalance(
    _reserve: string,
    _user: string,
    _balanceIncrease: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the state of the core as a consequence of a stable rate rebalance
   * @param _balanceIncrease the accrued interest on the borrowed amount
   * @param _reserve the address of the principal reserve where the user borrowed
   * @param _user the address of the borrower
   * @returns the new stable rate for the user*
   */
  "updateStateOnRebalance(address,address,uint256)"(
    _reserve: string,
    _user: string,
    _balanceIncrease: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables or disables a reserve as collateral
   * @param _reserve the address of the principal reserve where the user deposited
   * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
   * @param _user the address of the depositor
   */
  setUserUseReserveAsCollateral(
    _reserve: string,
    _user: string,
    _useAsCollateral: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables or disables a reserve as collateral
   * @param _reserve the address of the principal reserve where the user deposited
   * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
   * @param _user the address of the depositor
   */
  "setUserUseReserveAsCollateral(address,address,bool)"(
    _reserve: string,
    _user: string,
    _useAsCollateral: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * transfers to the user a specific amount from the reserve.
   * @param _amount the amount being transferred*
   * @param _reserve the address of the reserve where the transfer is happening
   * @param _user the address of the user receiving the transfer
   */
  transferToUser(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * transfers to the user a specific amount from the reserve.
   * @param _amount the amount being transferred*
   * @param _reserve the address of the reserve where the transfer is happening
   * @param _user the address of the user receiving the transfer
   */
  "transferToUser(address,address,uint256)"(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * transfers the protocol fees to the fees collection address
   * @param _amount the amount being transferred
   * @param _destination the fee receiver address*
   * @param _token the address of the token being transferred
   * @param _user the address of the user from where the transfer is happening
   */
  transferToFeeCollectionAddress(
    _token: string,
    _user: string,
    _amount: BigNumberish,
    _destination: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * transfers the protocol fees to the fees collection address
   * @param _amount the amount being transferred
   * @param _destination the fee receiver address*
   * @param _token the address of the token being transferred
   * @param _user the address of the user from where the transfer is happening
   */
  "transferToFeeCollectionAddress(address,address,uint256,address)"(
    _token: string,
    _user: string,
    _amount: BigNumberish,
    _destination: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * transfers the fees to the fees collection address in the case of liquidation
   * @param _amount the amount being transferred
   * @param _destination the fee receiver address*
   * @param _token the address of the token being transferred
   */
  liquidateFee(
    _token: string,
    _amount: BigNumberish,
    _destination: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * transfers the fees to the fees collection address in the case of liquidation
   * @param _amount the amount being transferred
   * @param _destination the fee receiver address*
   * @param _token the address of the token being transferred
   */
  "liquidateFee(address,uint256,address)"(
    _token: string,
    _amount: BigNumberish,
    _destination: string,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * transfers an amount from a user to the destination reserve
   * @param _amount the amount being transferred*
   * @param _reserve the address of the reserve where the amount is being transferred
   * @param _user the address of the user from where the transfer is happening
   */
  transferToReserve(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * transfers an amount from a user to the destination reserve
   * @param _amount the amount being transferred*
   * @param _reserve the address of the reserve where the amount is being transferred
   * @param _user the address of the user from where the transfer is happening
   */
  "transferToReserve(address,address,uint256)"(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: PayableOverrides
  ): Promise<ContractTransaction>;

  /**
   * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
   * @param _reserve the address of the reserve
   * @param _user the address of the user
   * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
   */
  getUserBasicReserveData(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: boolean;
  }>;

  /**
   * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
   * @param _reserve the address of the reserve
   * @param _user the address of the user
   * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
   */
  "getUserBasicReserveData(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: boolean;
  }>;

  /**
   * checks if a user is allowed to borrow at a stable rate
   * @param _amount the amount the the user wants to borrow
   * @param _reserve the reserve address
   * @param _user the user
   * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
   */
  isUserAllowedToBorrowAtStable(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * checks if a user is allowed to borrow at a stable rate
   * @param _amount the amount the the user wants to borrow
   * @param _reserve the reserve address
   * @param _user the user
   * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
   */
  "isUserAllowedToBorrowAtStable(address,address,uint256)"(
    _reserve: string,
    _user: string,
    _amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * gets the underlying asset balance of a user based on the corresponding aToken balance.
   * @param _reserve the reserve address
   * @param _user the user address
   * @returns the underlying deposit balance of the user*
   */
  getUserUnderlyingAssetBalance(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the underlying asset balance of a user based on the corresponding aToken balance.
   * @param _reserve the reserve address
   * @param _user the user address
   * @returns the underlying deposit balance of the user*
   */
  "getUserUnderlyingAssetBalance(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the interest rate strategy contract address for the reserve
   * @param _reserve the reserve address
   * @returns the address of the interest rate strategy contract*
   */
  getReserveInterestRateStrategyAddress(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * gets the interest rate strategy contract address for the reserve
   * @param _reserve the reserve address
   * @returns the address of the interest rate strategy contract*
   */
  "getReserveInterestRateStrategyAddress(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * gets the aToken contract address for the reserve
   * @param _reserve the reserve address
   * @returns the address of the aToken contract*
   */
  getReserveATokenAddress(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * gets the aToken contract address for the reserve
   * @param _reserve the reserve address
   * @returns the address of the aToken contract*
   */
  "getReserveATokenAddress(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
   * @param _reserve the reserve address
   * @returns the available liquidity*
   */
  getReserveAvailableLiquidity(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
   * @param _reserve the reserve address
   * @returns the available liquidity*
   */
  "getReserveAvailableLiquidity(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
   * @param _reserve the reserve address
   * @returns the total liquidity*
   */
  getReserveTotalLiquidity(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
   * @param _reserve the reserve address
   * @returns the total liquidity*
   */
  "getReserveTotalLiquidity(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
   * @param _reserve the reserve address
   * @returns the reserve normalized income*
   */
  getReserveNormalizedIncome(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
   * @param _reserve the reserve address
   * @returns the reserve normalized income*
   */
  "getReserveNormalizedIncome(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows
   * @param _reserve the reserve address
   * @returns the total borrows (stable + variable)*
   */
  getReserveTotalBorrows(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows
   * @param _reserve the reserve address
   * @returns the total borrows (stable + variable)*
   */
  "getReserveTotalBorrows(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows stable
   * @param _reserve the reserve address
   * @returns the total borrows stable*
   */
  getReserveTotalBorrowsStable(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows stable
   * @param _reserve the reserve address
   * @returns the total borrows stable*
   */
  "getReserveTotalBorrowsStable(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows variable
   * @param _reserve the reserve address
   * @returns the total borrows variable*
   */
  getReserveTotalBorrowsVariable(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve total borrows variable
   * @param _reserve the reserve address
   * @returns the total borrows variable*
   */
  "getReserveTotalBorrowsVariable(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidation threshold
   * @param _reserve the reserve address
   * @returns the reserve liquidation threshold*
   */
  getReserveLiquidationThreshold(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidation threshold
   * @param _reserve the reserve address
   * @returns the reserve liquidation threshold*
   */
  "getReserveLiquidationThreshold(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidation bonus
   * @param _reserve the reserve address
   * @returns the reserve liquidation bonus*
   */
  getReserveLiquidationBonus(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidation bonus
   * @param _reserve the reserve address
   * @returns the reserve liquidation bonus*
   */
  "getReserveLiquidationBonus(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
   * @param _reserve the reserve address
   * @returns the reserve current variable borrow rate*
   */
  getReserveCurrentVariableBorrowRate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
   * @param _reserve the reserve address
   * @returns the reserve current variable borrow rate*
   */
  "getReserveCurrentVariableBorrowRate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
   * @param _reserve the reserve address
   * @returns the reserve current stable borrow rate*
   */
  getReserveCurrentStableBorrowRate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
   * @param _reserve the reserve address
   * @returns the reserve current stable borrow rate*
   */
  "getReserveCurrentStableBorrowRate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
   * @param _reserve the reserve address
   * @returns the reserve current average borrow rate*
   */
  getReserveCurrentAverageStableBorrowRate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
   * @param _reserve the reserve address
   * @returns the reserve current average borrow rate*
   */
  "getReserveCurrentAverageStableBorrowRate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidity rate
   * @param _reserve the reserve address
   * @returns the reserve liquidity rate*
   */
  getReserveCurrentLiquidityRate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidity rate
   * @param _reserve the reserve address
   * @returns the reserve liquidity rate*
   */
  "getReserveCurrentLiquidityRate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidity cumulative index
   * @param _reserve the reserve address
   * @returns the reserve liquidity cumulative index*
   */
  getReserveLiquidityCumulativeIndex(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve liquidity cumulative index
   * @param _reserve the reserve address
   * @returns the reserve liquidity cumulative index*
   */
  "getReserveLiquidityCumulativeIndex(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve variable borrow index
   * @param _reserve the reserve address
   * @returns the reserve variable borrow index*
   */
  getReserveVariableBorrowsCumulativeIndex(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * gets the reserve variable borrow index
   * @param _reserve the reserve address
   * @returns the reserve variable borrow index*
   */
  "getReserveVariableBorrowsCumulativeIndex(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
   * @param _reserve the reserve address
   * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
   */
  getReserveConfiguration(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: boolean;
  }>;

  /**
   * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
   * @param _reserve the reserve address
   * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
   */
  "getReserveConfiguration(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
    3: boolean;
  }>;

  /**
   * returns the decimals of the reserve
   * @param _reserve the reserve address
   * @returns the reserve decimals*
   */
  getReserveDecimals(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * returns the decimals of the reserve
   * @param _reserve the reserve address
   * @returns the reserve decimals*
   */
  "getReserveDecimals(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * returns true if the reserve is enabled for borrowing
   * @param _reserve the reserve address
   * @returns true if the reserve is enabled for borrowing, false otherwise*
   */
  isReserveBorrowingEnabled(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the reserve is enabled for borrowing
   * @param _reserve the reserve address
   * @returns true if the reserve is enabled for borrowing, false otherwise*
   */
  "isReserveBorrowingEnabled(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the reserve is enabled as collateral
   * @param _reserve the reserve address
   * @returns true if the reserve is enabled as collateral, false otherwise*
   */
  isReserveUsageAsCollateralEnabled(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the reserve is enabled as collateral
   * @param _reserve the reserve address
   * @returns true if the reserve is enabled as collateral, false otherwise*
   */
  "isReserveUsageAsCollateralEnabled(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the stable rate is enabled on reserve
   * @param _reserve the reserve address
   * @returns true if the stable rate is enabled on reserve, false otherwise*
   */
  getReserveIsStableBorrowRateEnabled(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the stable rate is enabled on reserve
   * @param _reserve the reserve address
   * @returns true if the stable rate is enabled on reserve, false otherwise*
   */
  "getReserveIsStableBorrowRateEnabled(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the reserve is active
   * @param _reserve the reserve address
   * @returns true if the reserve is active, false otherwise*
   */
  getReserveIsActive(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns true if the reserve is active
   * @param _reserve the reserve address
   * @returns true if the reserve is active, false otherwise*
   */
  "getReserveIsActive(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns if a reserve is freezed
   * @param _reserve the reserve for which the information is needed
   * @returns true if the reserve is freezed, false otherwise*
   */
  getReserveIsFreezed(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns if a reserve is freezed
   * @param _reserve the reserve for which the information is needed
   * @returns true if the reserve is freezed, false otherwise*
   */
  "getReserveIsFreezed(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * returns the timestamp of the last action on the reserve
   * @param _reserve the reserve for which the information is needed
   * @returns the last updated timestamp of the reserve*
   */
  getReserveLastUpdate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * returns the timestamp of the last action on the reserve
   * @param _reserve the reserve for which the information is needed
   * @returns the last updated timestamp of the reserve*
   */
  "getReserveLastUpdate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * returns the utilization rate U of a specific reserve
   * @param _reserve the reserve for which the information is needed
   * @returns the utilization rate in ray*
   */
  getReserveUtilizationRate(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * returns the utilization rate U of a specific reserve
   * @param _reserve the reserve for which the information is needed
   * @returns the utilization rate in ray*
   */
  "getReserveUtilizationRate(address)"(
    _reserve: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * @returns the array of reserves configured on the core*
   */
  getReserves(overrides?: CallOverrides): Promise<string[]>;

  /**
   * @returns the array of reserves configured on the core*
   */
  "getReserves()"(overrides?: CallOverrides): Promise<string[]>;

  /**
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
   */
  isUserUseReserveAsCollateralEnabled(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
   */
  "isUserUseReserveAsCollateralEnabled(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the origination fee for the user*
   */
  getUserOriginationFee(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the origination fee for the user*
   */
  "getUserOriginationFee(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * users with no loans in progress have NONE as borrow rate mode
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the borrow rate mode for the user,*
   */
  getUserCurrentBorrowRateMode(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * users with no loans in progress have NONE as borrow rate mode
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the borrow rate mode for the user,*
   */
  "getUserCurrentBorrowRateMode(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<number>;

  /**
   * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the user stable rate*
   */
  getUserCurrentStableBorrowRate(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the user stable rate*
   */
  "getUserCurrentStableBorrowRate(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * calculates and returns the borrow balances of the user
   * @param _reserve the address of the reserve
   * @param _user the address of the user
   * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
   */
  getUserBorrowBalances(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
  }>;

  /**
   * calculates and returns the borrow balances of the user
   * @param _reserve the address of the reserve
   * @param _user the address of the user
   * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
   */
  "getUserBorrowBalances(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<{
    0: BigNumber;
    1: BigNumber;
    2: BigNumber;
  }>;

  /**
   * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the variable borrow index for the user*
   */
  getUserVariableBorrowCumulativeIndex(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the variable borrow index for the user*
   */
  "getUserVariableBorrowCumulativeIndex(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the variable borrow index for the user*
   */
  getUserLastUpdate(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
   * @param _reserve the address of the reserve for which the information is needed
   * @param _user the address of the user for which the information is needed
   * @returns the variable borrow index for the user*
   */
  "getUserLastUpdate(address,address)"(
    _reserve: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * updates the lending pool core configuration*
   */
  refreshConfiguration(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * updates the lending pool core configuration*
   */
  "refreshConfiguration()"(overrides?: Overrides): Promise<ContractTransaction>;

  /**
   * initializes a reserve
   * @param _aTokenAddress the address of the overlying aToken contract
   * @param _decimals the decimals of the reserve currency
   * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
   * @param _reserve the address of the reserve
   */
  initReserve(
    _reserve: string,
    _aTokenAddress: string,
    _decimals: BigNumberish,
    _interestRateStrategyAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * initializes a reserve
   * @param _aTokenAddress the address of the overlying aToken contract
   * @param _decimals the decimals of the reserve currency
   * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
   * @param _reserve the address of the reserve
   */
  "initReserve(address,address,uint256,address)"(
    _reserve: string,
    _aTokenAddress: string,
    _decimals: BigNumberish,
    _interestRateStrategyAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * removes the last added reserve in the reservesList array
   * @param _reserveToRemove the address of the reserve*
   */
  removeLastAddedReserve(
    _reserveToRemove: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * removes the last added reserve in the reservesList array
   * @param _reserveToRemove the address of the reserve*
   */
  "removeLastAddedReserve(address)"(
    _reserveToRemove: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the address of the interest rate strategy contract
   * @param _rateStrategyAddress the address of the interest rate strategy contract*
   * @param _reserve the address of the reserve
   */
  setReserveInterestRateStrategyAddress(
    _reserve: string,
    _rateStrategyAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * updates the address of the interest rate strategy contract
   * @param _rateStrategyAddress the address of the interest rate strategy contract*
   * @param _reserve the address of the reserve
   */
  "setReserveInterestRateStrategyAddress(address,address)"(
    _reserve: string,
    _rateStrategyAddress: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables borrowing on a reserve. Also sets the stable rate borrowing
   * @param _reserve the address of the reserve
   * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
   */
  enableBorrowingOnReserve(
    _reserve: string,
    _stableBorrowRateEnabled: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables borrowing on a reserve. Also sets the stable rate borrowing
   * @param _reserve the address of the reserve
   * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
   */
  "enableBorrowingOnReserve(address,bool)"(
    _reserve: string,
    _stableBorrowRateEnabled: boolean,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disables borrowing on a reserve
   * @param _reserve the address of the reserve*
   */
  disableBorrowingOnReserve(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disables borrowing on a reserve
   * @param _reserve the address of the reserve*
   */
  "disableBorrowingOnReserve(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables a reserve to be used as collateral
   * @param _reserve the address of the reserve*
   */
  enableReserveAsCollateral(
    _reserve: string,
    _baseLTVasCollateral: BigNumberish,
    _liquidationThreshold: BigNumberish,
    _liquidationBonus: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enables a reserve to be used as collateral
   * @param _reserve the address of the reserve*
   */
  "enableReserveAsCollateral(address,uint256,uint256,uint256)"(
    _reserve: string,
    _baseLTVasCollateral: BigNumberish,
    _liquidationThreshold: BigNumberish,
    _liquidationBonus: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disables a reserve to be used as collateral
   * @param _reserve the address of the reserve*
   */
  disableReserveAsCollateral(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disables a reserve to be used as collateral
   * @param _reserve the address of the reserve*
   */
  "disableReserveAsCollateral(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enable the stable borrow rate mode on a reserve
   * @param _reserve the address of the reserve*
   */
  enableReserveStableBorrowRate(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * enable the stable borrow rate mode on a reserve
   * @param _reserve the address of the reserve*
   */
  "enableReserveStableBorrowRate(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disable the stable borrow rate mode on a reserve
   * @param _reserve the address of the reserve*
   */
  disableReserveStableBorrowRate(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * disable the stable borrow rate mode on a reserve
   * @param _reserve the address of the reserve*
   */
  "disableReserveStableBorrowRate(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * activates a reserve
   * @param _reserve the address of the reserve*
   */
  activateReserve(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * activates a reserve
   * @param _reserve the address of the reserve*
   */
  "activateReserve(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * deactivates a reserve
   * @param _reserve the address of the reserve*
   */
  deactivateReserve(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * deactivates a reserve
   * @param _reserve the address of the reserve*
   */
  "deactivateReserve(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
   * @param _reserve the address of the reserve*
   */
  freezeReserve(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
   * @param _reserve the address of the reserve*
   */
  "freezeReserve(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
   * @param _reserve the address of the reserve*
   */
  unfreezeReserve(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
   * @param _reserve the address of the reserve*
   */
  "unfreezeReserve(address)"(
    _reserve: string,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the loan to value of a reserve
   * @param _ltv the new loan to value*
   * @param _reserve the address of the reserve
   */
  setReserveBaseLTVasCollateral(
    _reserve: string,
    _ltv: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the loan to value of a reserve
   * @param _ltv the new loan to value*
   * @param _reserve the address of the reserve
   */
  "setReserveBaseLTVasCollateral(address,uint256)"(
    _reserve: string,
    _ltv: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the liquidation threshold of a reserve
   * @param _reserve the address of the reserve
   * @param _threshold the new liquidation threshold*
   */
  setReserveLiquidationThreshold(
    _reserve: string,
    _threshold: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the liquidation threshold of a reserve
   * @param _reserve the address of the reserve
   * @param _threshold the new liquidation threshold*
   */
  "setReserveLiquidationThreshold(address,uint256)"(
    _reserve: string,
    _threshold: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the liquidation bonus of a reserve
   * @param _bonus the new liquidation bonus*
   * @param _reserve the address of the reserve
   */
  setReserveLiquidationBonus(
    _reserve: string,
    _bonus: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the liquidation bonus of a reserve
   * @param _bonus the new liquidation bonus*
   * @param _reserve the address of the reserve
   */
  "setReserveLiquidationBonus(address,uint256)"(
    _reserve: string,
    _bonus: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the reserve decimals
   * @param _decimals the decimals of the reserve*
   * @param _reserve the address of the reserve
   */
  setReserveDecimals(
    _reserve: string,
    _decimals: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  /**
   * allows the configurator to update the reserve decimals
   * @param _decimals the decimals of the reserve*
   * @param _reserve the address of the reserve
   */
  "setReserveDecimals(address,uint256)"(
    _reserve: string,
    _decimals: BigNumberish,
    overrides?: Overrides
  ): Promise<ContractTransaction>;

  callStatic: {
    CORE_REVISION(overrides?: CallOverrides): Promise<BigNumber>;

    "CORE_REVISION()"(overrides?: CallOverrides): Promise<BigNumber>;

    addressesProvider(overrides?: CallOverrides): Promise<string>;

    "addressesProvider()"(overrides?: CallOverrides): Promise<string>;

    lendingPoolAddress(overrides?: CallOverrides): Promise<string>;

    "lendingPoolAddress()"(overrides?: CallOverrides): Promise<string>;

    reservesList(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "reservesList(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    initialize(
      _addressesProvider: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    "initialize(address)"(
      _addressesProvider: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    updateStateOnDeposit(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    "updateStateOnDeposit(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    updateStateOnRedeem(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    "updateStateOnRedeem(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    updateStateOnFlashLoan(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    "updateStateOnFlashLoan(address,uint256,uint256,uint256)"(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    updateStateOnBorrow(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
    }>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    "updateStateOnBorrow(address,address,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
    }>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnRepay(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)"(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnSwapRate(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: BigNumber;
    }>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: CallOverrides
    ): Promise<{
      0: number;
      1: BigNumber;
    }>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    updateStateOnLiquidation(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)"(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    updateStateOnRebalance(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    "updateStateOnRebalance(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    setUserUseReserveAsCollateral(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    "setUserUseReserveAsCollateral(address,address,bool)"(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    transferToUser(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    "transferToUser(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToFeeCollectionAddress(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToFeeCollectionAddress(address,address,uint256,address)"(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    liquidateFee(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    "liquidateFee(address,uint256,address)"(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToReserve(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToReserve(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    getUserBasicReserveData(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    "getUserBasicReserveData(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    isUserAllowedToBorrowAtStable(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    "isUserAllowedToBorrowAtStable(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    getUserUnderlyingAssetBalance(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    "getUserUnderlyingAssetBalance(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    getReserveInterestRateStrategyAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    "getReserveInterestRateStrategyAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    getReserveATokenAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    "getReserveATokenAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    getReserveAvailableLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    "getReserveAvailableLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    getReserveTotalLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    "getReserveTotalLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    getReserveNormalizedIncome(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    "getReserveNormalizedIncome(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    getReserveTotalBorrows(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    "getReserveTotalBorrows(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    getReserveTotalBorrowsStable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    "getReserveTotalBorrowsStable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    getReserveTotalBorrowsVariable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    "getReserveTotalBorrowsVariable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    getReserveLiquidationThreshold(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    "getReserveLiquidationThreshold(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    getReserveLiquidationBonus(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    "getReserveLiquidationBonus(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    getReserveCurrentVariableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    "getReserveCurrentVariableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    getReserveCurrentStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    "getReserveCurrentStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    getReserveCurrentAverageStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    "getReserveCurrentAverageStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    getReserveCurrentLiquidityRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    "getReserveCurrentLiquidityRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    getReserveLiquidityCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    "getReserveLiquidityCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    getReserveVariableBorrowsCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    "getReserveVariableBorrowsCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    getReserveConfiguration(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    "getReserveConfiguration(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: boolean;
    }>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    getReserveDecimals(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    "getReserveDecimals(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    isReserveBorrowingEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    "isReserveBorrowingEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    isReserveUsageAsCollateralEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    "isReserveUsageAsCollateralEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    getReserveIsStableBorrowRateEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    "getReserveIsStableBorrowRateEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    getReserveIsActive(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    "getReserveIsActive(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    getReserveIsFreezed(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    "getReserveIsFreezed(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    getReserveLastUpdate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    "getReserveLastUpdate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    getReserveUtilizationRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    "getReserveUtilizationRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @returns the array of reserves configured on the core*
     */
    getReserves(overrides?: CallOverrides): Promise<string[]>;

    /**
     * @returns the array of reserves configured on the core*
     */
    "getReserves()"(overrides?: CallOverrides): Promise<string[]>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    isUserUseReserveAsCollateralEnabled(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    "isUserUseReserveAsCollateralEnabled(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    getUserOriginationFee(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    "getUserOriginationFee(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    getUserCurrentBorrowRateMode(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    "getUserCurrentBorrowRateMode(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<number>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    getUserCurrentStableBorrowRate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    "getUserCurrentStableBorrowRate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    getUserBorrowBalances(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
    }>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    "getUserBorrowBalances(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<{
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
    }>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserVariableBorrowCumulativeIndex(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserVariableBorrowCumulativeIndex(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserLastUpdate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserLastUpdate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * updates the lending pool core configuration*
     */
    refreshConfiguration(overrides?: CallOverrides): Promise<void>;

    /**
     * updates the lending pool core configuration*
     */
    "refreshConfiguration()"(overrides?: CallOverrides): Promise<void>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    initReserve(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "initReserve(address,address,uint256,address)"(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    removeLastAddedReserve(
      _reserveToRemove: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    "removeLastAddedReserve(address)"(
      _reserveToRemove: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    setReserveInterestRateStrategyAddress(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "setReserveInterestRateStrategyAddress(address,address)"(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    enableBorrowingOnReserve(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    "enableBorrowingOnReserve(address,bool)"(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    disableBorrowingOnReserve(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableBorrowingOnReserve(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    enableReserveAsCollateral(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "enableReserveAsCollateral(address,uint256,uint256,uint256)"(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    disableReserveAsCollateral(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "disableReserveAsCollateral(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    enableReserveStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "enableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    disableReserveStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    activateReserve(_reserve: string, overrides?: CallOverrides): Promise<void>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    "activateReserve(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    deactivateReserve(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    "deactivateReserve(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    freezeReserve(_reserve: string, overrides?: CallOverrides): Promise<void>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    "freezeReserve(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    unfreezeReserve(_reserve: string, overrides?: CallOverrides): Promise<void>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    "unfreezeReserve(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    setReserveBaseLTVasCollateral(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    "setReserveBaseLTVasCollateral(address,uint256)"(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    setReserveLiquidationThreshold(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    "setReserveLiquidationThreshold(address,uint256)"(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    setReserveLiquidationBonus(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    "setReserveLiquidationBonus(address,uint256)"(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    setReserveDecimals(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    "setReserveDecimals(address,uint256)"(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    ReserveDataUpdated(
      reserve: string | null,
      liquidityRate: null,
      stableBorrowRate: null,
      averageStableBorrowRate: null,
      variableBorrowRate: null,
      liquidityIndex: null,
      variableBorrowIndex: null
    ): EventFilter;

    ReserveUpdated(
      reserve: string | null,
      liquidityRate: null,
      stableBorrowRate: null,
      variableBorrowRate: null,
      liquidityIndex: null,
      variableBorrowIndex: null
    ): EventFilter;
  };

  estimateGas: {
    CORE_REVISION(overrides?: CallOverrides): Promise<BigNumber>;

    "CORE_REVISION()"(overrides?: CallOverrides): Promise<BigNumber>;

    addressesProvider(overrides?: CallOverrides): Promise<BigNumber>;

    "addressesProvider()"(overrides?: CallOverrides): Promise<BigNumber>;

    lendingPoolAddress(overrides?: CallOverrides): Promise<BigNumber>;

    "lendingPoolAddress()"(overrides?: CallOverrides): Promise<BigNumber>;

    reservesList(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "reservesList(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    initialize(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    "initialize(address)"(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    updateStateOnDeposit(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    "updateStateOnDeposit(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    updateStateOnRedeem(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    "updateStateOnRedeem(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    updateStateOnFlashLoan(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    "updateStateOnFlashLoan(address,uint256,uint256,uint256)"(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    updateStateOnBorrow(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    "updateStateOnBorrow(address,address,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnRepay(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)"(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnSwapRate(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    updateStateOnLiquidation(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)"(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    updateStateOnRebalance(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    "updateStateOnRebalance(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    setUserUseReserveAsCollateral(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    "setUserUseReserveAsCollateral(address,address,bool)"(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    transferToUser(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    "transferToUser(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToFeeCollectionAddress(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToFeeCollectionAddress(address,address,uint256,address)"(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    liquidateFee(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    "liquidateFee(address,uint256,address)"(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToReserve(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToReserve(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<BigNumber>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    getUserBasicReserveData(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    "getUserBasicReserveData(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    isUserAllowedToBorrowAtStable(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    "isUserAllowedToBorrowAtStable(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    getUserUnderlyingAssetBalance(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    "getUserUnderlyingAssetBalance(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    getReserveInterestRateStrategyAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    "getReserveInterestRateStrategyAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    getReserveATokenAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    "getReserveATokenAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    getReserveAvailableLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    "getReserveAvailableLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    getReserveTotalLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    "getReserveTotalLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    getReserveNormalizedIncome(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    "getReserveNormalizedIncome(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    getReserveTotalBorrows(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    "getReserveTotalBorrows(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    getReserveTotalBorrowsStable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    "getReserveTotalBorrowsStable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    getReserveTotalBorrowsVariable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    "getReserveTotalBorrowsVariable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    getReserveLiquidationThreshold(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    "getReserveLiquidationThreshold(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    getReserveLiquidationBonus(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    "getReserveLiquidationBonus(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    getReserveCurrentVariableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    "getReserveCurrentVariableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    getReserveCurrentStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    "getReserveCurrentStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    getReserveCurrentAverageStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    "getReserveCurrentAverageStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    getReserveCurrentLiquidityRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    "getReserveCurrentLiquidityRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    getReserveLiquidityCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    "getReserveLiquidityCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    getReserveVariableBorrowsCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    "getReserveVariableBorrowsCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    getReserveConfiguration(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    "getReserveConfiguration(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    getReserveDecimals(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    "getReserveDecimals(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    isReserveBorrowingEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    "isReserveBorrowingEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    isReserveUsageAsCollateralEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    "isReserveUsageAsCollateralEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    getReserveIsStableBorrowRateEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    "getReserveIsStableBorrowRateEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    getReserveIsActive(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    "getReserveIsActive(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    getReserveIsFreezed(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    "getReserveIsFreezed(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    getReserveLastUpdate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    "getReserveLastUpdate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    getReserveUtilizationRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    "getReserveUtilizationRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @returns the array of reserves configured on the core*
     */
    getReserves(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * @returns the array of reserves configured on the core*
     */
    "getReserves()"(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    isUserUseReserveAsCollateralEnabled(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    "isUserUseReserveAsCollateralEnabled(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    getUserOriginationFee(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    "getUserOriginationFee(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    getUserCurrentBorrowRateMode(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    "getUserCurrentBorrowRateMode(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    getUserCurrentStableBorrowRate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    "getUserCurrentStableBorrowRate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    getUserBorrowBalances(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    "getUserBorrowBalances(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserVariableBorrowCumulativeIndex(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserVariableBorrowCumulativeIndex(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserLastUpdate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserLastUpdate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * updates the lending pool core configuration*
     */
    refreshConfiguration(overrides?: Overrides): Promise<BigNumber>;

    /**
     * updates the lending pool core configuration*
     */
    "refreshConfiguration()"(overrides?: Overrides): Promise<BigNumber>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    initReserve(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "initReserve(address,address,uint256,address)"(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    removeLastAddedReserve(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    "removeLastAddedReserve(address)"(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    setReserveInterestRateStrategyAddress(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "setReserveInterestRateStrategyAddress(address,address)"(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    enableBorrowingOnReserve(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    "enableBorrowingOnReserve(address,bool)"(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    disableBorrowingOnReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableBorrowingOnReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    enableReserveAsCollateral(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "enableReserveAsCollateral(address,uint256,uint256,uint256)"(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    disableReserveAsCollateral(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "disableReserveAsCollateral(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    enableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "enableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    disableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    activateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    "activateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    deactivateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    "deactivateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    freezeReserve(_reserve: string, overrides?: Overrides): Promise<BigNumber>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    "freezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    unfreezeReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    "unfreezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    setReserveBaseLTVasCollateral(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    "setReserveBaseLTVasCollateral(address,uint256)"(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    setReserveLiquidationThreshold(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    "setReserveLiquidationThreshold(address,uint256)"(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    setReserveLiquidationBonus(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    "setReserveLiquidationBonus(address,uint256)"(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    setReserveDecimals(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    "setReserveDecimals(address,uint256)"(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    CORE_REVISION(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "CORE_REVISION()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    addressesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "addressesProvider()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lendingPoolAddress(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "lendingPoolAddress()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    reservesList(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "reservesList(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    initialize(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * initializes the Core contract, invoked upon registration on the AddressesProvider
     * @param _addressesProvider the addressesProvider contract*
     */
    "initialize(address)"(
      _addressesProvider: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    updateStateOnDeposit(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a deposit action
     * @param _amount the amount being deposited
     * @param _isFirstDeposit true if the user is depositing for the first time*
     * @param _reserve the address of the reserve in which the deposit is happening
     * @param _user the address of the the user depositing
     */
    "updateStateOnDeposit(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      _isFirstDeposit: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    updateStateOnRedeem(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a redeem action
     * @param _amountRedeemed the amount being redeemed
     * @param _reserve the address of the reserve in which the redeem is happening
     * @param _user the address of the the user redeeming
     * @param _userRedeemedEverything true if the user is redeeming everything*
     */
    "updateStateOnRedeem(address,address,uint256,bool)"(
      _reserve: string,
      _user: string,
      _amountRedeemed: BigNumberish,
      _userRedeemedEverything: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    updateStateOnFlashLoan(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a result of a flashloan action
     * @param _income the income of the protocol as a result of the action*
     * @param _reserve the address of the reserve in which the flashloan is happening
     */
    "updateStateOnFlashLoan(address,uint256,uint256,uint256)"(
      _reserve: string,
      _availableLiquidityBefore: BigNumberish,
      _income: BigNumberish,
      _protocolFee: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    updateStateOnBorrow(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a borrow action.
     * @param _amountBorrowed the new amount borrowed
     * @param _borrowFee the fee on the amount borrowed
     * @param _rateMode the borrow rate mode (stable, variable)
     * @param _reserve the address of the reserve on which the user is borrowing
     * @param _user the address of the borrower
     * @returns the new borrow rate for the user*
     */
    "updateStateOnBorrow(address,address,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _amountBorrowed: BigNumberish,
      _borrowFee: BigNumberish,
      _rateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnRepay(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a repay action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _originationFeeRepaid the fee on the amount that is being repaid
     * @param _paybackAmountMinusFees the amount being paid back minus fees
     * @param _repaidWholeLoan true if the user is repaying the whole loan*
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnRepay(address,address,uint256,uint256,uint256,bool)"(
      _reserve: string,
      _user: string,
      _paybackAmountMinusFees: BigNumberish,
      _originationFeeRepaid: BigNumberish,
      _balanceIncrease: BigNumberish,
      _repaidWholeLoan: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    updateStateOnSwapRate(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a swap rate action.
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _compoundedBorrowBalance the amount borrowed plus accrued interest
     * @param _currentRateMode the current interest rate mode for the user*
     * @param _principalBorrowBalance the amount borrowed by the user
     * @param _reserve the address of the reserve on which the user is repaying
     * @param _user the address of the borrower
     */
    "updateStateOnSwapRate(address,address,uint256,uint256,uint256,uint8)"(
      _reserve: string,
      _user: string,
      _principalBorrowBalance: BigNumberish,
      _compoundedBorrowBalance: BigNumberish,
      _balanceIncrease: BigNumberish,
      _currentRateMode: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    updateStateOnLiquidation(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a liquidation action.
     * @param _amountToLiquidate the amount being repaid by the liquidator
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _collateralReserve the address of the collateral reserve that is being liquidated
     * @param _collateralToLiquidate the amount of collateral being liquidated
     * @param _feeLiquidated the amount of origination fee being liquidated
     * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus
     * @param _liquidatorReceivesAToken true if the liquidator will receive aTokens, false otherwise*
     * @param _principalReserve the address of the principal reserve that is being repaid
     * @param _user the address of the borrower
     */
    "updateStateOnLiquidation(address,address,address,uint256,uint256,uint256,uint256,uint256,bool)"(
      _principalReserve: string,
      _collateralReserve: string,
      _user: string,
      _amountToLiquidate: BigNumberish,
      _collateralToLiquidate: BigNumberish,
      _feeLiquidated: BigNumberish,
      _liquidatedCollateralForFee: BigNumberish,
      _balanceIncrease: BigNumberish,
      _liquidatorReceivesAToken: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    updateStateOnRebalance(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the state of the core as a consequence of a stable rate rebalance
     * @param _balanceIncrease the accrued interest on the borrowed amount
     * @param _reserve the address of the principal reserve where the user borrowed
     * @param _user the address of the borrower
     * @returns the new stable rate for the user*
     */
    "updateStateOnRebalance(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _balanceIncrease: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    setUserUseReserveAsCollateral(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables or disables a reserve as collateral
     * @param _reserve the address of the principal reserve where the user deposited
     * @param _useAsCollateral true if the depositor wants to use the reserve as collateral*
     * @param _user the address of the depositor
     */
    "setUserUseReserveAsCollateral(address,address,bool)"(
      _reserve: string,
      _user: string,
      _useAsCollateral: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    transferToUser(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers to the user a specific amount from the reserve.
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the transfer is happening
     * @param _user the address of the user receiving the transfer
     */
    "transferToUser(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToFeeCollectionAddress(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers the protocol fees to the fees collection address
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToFeeCollectionAddress(address,address,uint256,address)"(
      _token: string,
      _user: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    liquidateFee(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers the fees to the fees collection address in the case of liquidation
     * @param _amount the amount being transferred
     * @param _destination the fee receiver address*
     * @param _token the address of the token being transferred
     */
    "liquidateFee(address,uint256,address)"(
      _token: string,
      _amount: BigNumberish,
      _destination: string,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    transferToReserve(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * transfers an amount from a user to the destination reserve
     * @param _amount the amount being transferred*
     * @param _reserve the address of the reserve where the amount is being transferred
     * @param _user the address of the user from where the transfer is happening
     */
    "transferToReserve(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: PayableOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    getUserBasicReserveData(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral) needed to calculate the global account data in the LendingPoolDataProvider
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not*
     */
    "getUserBasicReserveData(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    isUserAllowedToBorrowAtStable(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * checks if a user is allowed to borrow at a stable rate
     * @param _amount the amount the the user wants to borrow
     * @param _reserve the reserve address
     * @param _user the user
     * @returns true if the user is allowed to borrow at a stable rate, false otherwise*
     */
    "isUserAllowedToBorrowAtStable(address,address,uint256)"(
      _reserve: string,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    getUserUnderlyingAssetBalance(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the underlying asset balance of a user based on the corresponding aToken balance.
     * @param _reserve the reserve address
     * @param _user the user address
     * @returns the underlying deposit balance of the user*
     */
    "getUserUnderlyingAssetBalance(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    getReserveInterestRateStrategyAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the interest rate strategy contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the interest rate strategy contract*
     */
    "getReserveInterestRateStrategyAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    getReserveATokenAddress(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the aToken contract address for the reserve
     * @param _reserve the reserve address
     * @returns the address of the aToken contract*
     */
    "getReserveATokenAddress(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    getReserveAvailableLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the available liquidity in the reserve. The available liquidity is the balance of the core contract
     * @param _reserve the reserve address
     * @returns the available liquidity*
     */
    "getReserveAvailableLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    getReserveTotalLiquidity(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows
     * @param _reserve the reserve address
     * @returns the total liquidity*
     */
    "getReserveTotalLiquidity(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    getReserveNormalizedIncome(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there there has been 100% income.
     * @param _reserve the reserve address
     * @returns the reserve normalized income*
     */
    "getReserveNormalizedIncome(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    getReserveTotalBorrows(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows
     * @param _reserve the reserve address
     * @returns the total borrows (stable + variable)*
     */
    "getReserveTotalBorrows(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    getReserveTotalBorrowsStable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows stable
     * @param _reserve the reserve address
     * @returns the total borrows stable*
     */
    "getReserveTotalBorrowsStable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    getReserveTotalBorrowsVariable(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve total borrows variable
     * @param _reserve the reserve address
     * @returns the total borrows variable*
     */
    "getReserveTotalBorrowsVariable(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    getReserveLiquidationThreshold(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidation threshold
     * @param _reserve the reserve address
     * @returns the reserve liquidation threshold*
     */
    "getReserveLiquidationThreshold(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    getReserveLiquidationBonus(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidation bonus
     * @param _reserve the reserve address
     * @returns the reserve liquidation bonus*
     */
    "getReserveLiquidationBonus(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    getReserveCurrentVariableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current variable borrow rate*
     */
    "getReserveCurrentVariableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    getReserveCurrentStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve current stable borrow rate. Is the market rate if the reserve is empty
     * @param _reserve the reserve address
     * @returns the reserve current stable borrow rate*
     */
    "getReserveCurrentStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    getReserveCurrentAverageStableBorrowRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve average stable borrow rate. The average stable rate is the weighted average of all the loans taken at stable rate.
     * @param _reserve the reserve address
     * @returns the reserve current average borrow rate*
     */
    "getReserveCurrentAverageStableBorrowRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    getReserveCurrentLiquidityRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidity rate
     * @param _reserve the reserve address
     * @returns the reserve liquidity rate*
     */
    "getReserveCurrentLiquidityRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    getReserveLiquidityCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve liquidity cumulative index
     * @param _reserve the reserve address
     * @returns the reserve liquidity cumulative index*
     */
    "getReserveLiquidityCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    getReserveVariableBorrowsCumulativeIndex(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * gets the reserve variable borrow index
     * @param _reserve the reserve address
     * @returns the reserve variable borrow index*
     */
    "getReserveVariableBorrowsCumulativeIndex(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    getReserveConfiguration(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * this function aggregates the configuration parameters of the reserve. It's used in the LendingPoolDataProvider specifically to save gas, and avoid multiple external contract calls to fetch the same data.
     * @param _reserve the reserve address
     * @returns the reserve decimalsthe base ltv as collateralthe liquidation thresholdif the reserve is used as collateral or not*
     */
    "getReserveConfiguration(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    getReserveDecimals(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the decimals of the reserve
     * @param _reserve the reserve address
     * @returns the reserve decimals*
     */
    "getReserveDecimals(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    isReserveBorrowingEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is enabled for borrowing
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled for borrowing, false otherwise*
     */
    "isReserveBorrowingEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    isReserveUsageAsCollateralEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is enabled as collateral
     * @param _reserve the reserve address
     * @returns true if the reserve is enabled as collateral, false otherwise*
     */
    "isReserveUsageAsCollateralEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    getReserveIsStableBorrowRateEnabled(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the stable rate is enabled on reserve
     * @param _reserve the reserve address
     * @returns true if the stable rate is enabled on reserve, false otherwise*
     */
    "getReserveIsStableBorrowRateEnabled(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    getReserveIsActive(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns true if the reserve is active
     * @param _reserve the reserve address
     * @returns true if the reserve is active, false otherwise*
     */
    "getReserveIsActive(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    getReserveIsFreezed(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns if a reserve is freezed
     * @param _reserve the reserve for which the information is needed
     * @returns true if the reserve is freezed, false otherwise*
     */
    "getReserveIsFreezed(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    getReserveLastUpdate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the timestamp of the last action on the reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the last updated timestamp of the reserve*
     */
    "getReserveLastUpdate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    getReserveUtilizationRate(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * returns the utilization rate U of a specific reserve
     * @param _reserve the reserve for which the information is needed
     * @returns the utilization rate in ray*
     */
    "getReserveUtilizationRate(address)"(
      _reserve: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @returns the array of reserves configured on the core*
     */
    getReserves(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * @returns the array of reserves configured on the core*
     */
    "getReserves()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    isUserUseReserveAsCollateralEnabled(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns true if the user has chosen to use the reserve as collateral, false otherwise*
     */
    "isUserUseReserveAsCollateralEnabled(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    getUserOriginationFee(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the origination fee for the user*
     */
    "getUserOriginationFee(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    getUserCurrentBorrowRateMode(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * users with no loans in progress have NONE as borrow rate mode
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the borrow rate mode for the user,*
     */
    "getUserCurrentBorrowRateMode(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    getUserCurrentStableBorrowRate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the user stable rate*
     */
    "getUserCurrentStableBorrowRate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    getUserBorrowBalances(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * calculates and returns the borrow balances of the user
     * @param _reserve the address of the reserve
     * @param _user the address of the user
     * @returns the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance*
     */
    "getUserBorrowBalances(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserVariableBorrowCumulativeIndex(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserVariableBorrowCumulativeIndex(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    getUserLastUpdate(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable
     * @param _reserve the address of the reserve for which the information is needed
     * @param _user the address of the user for which the information is needed
     * @returns the variable borrow index for the user*
     */
    "getUserLastUpdate(address,address)"(
      _reserve: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the lending pool core configuration*
     */
    refreshConfiguration(overrides?: Overrides): Promise<PopulatedTransaction>;

    /**
     * updates the lending pool core configuration*
     */
    "refreshConfiguration()"(
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    initReserve(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * initializes a reserve
     * @param _aTokenAddress the address of the overlying aToken contract
     * @param _decimals the decimals of the reserve currency
     * @param _interestRateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "initReserve(address,address,uint256,address)"(
      _reserve: string,
      _aTokenAddress: string,
      _decimals: BigNumberish,
      _interestRateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    removeLastAddedReserve(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * removes the last added reserve in the reservesList array
     * @param _reserveToRemove the address of the reserve*
     */
    "removeLastAddedReserve(address)"(
      _reserveToRemove: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    setReserveInterestRateStrategyAddress(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * updates the address of the interest rate strategy contract
     * @param _rateStrategyAddress the address of the interest rate strategy contract*
     * @param _reserve the address of the reserve
     */
    "setReserveInterestRateStrategyAddress(address,address)"(
      _reserve: string,
      _rateStrategyAddress: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    enableBorrowingOnReserve(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables borrowing on a reserve. Also sets the stable rate borrowing
     * @param _reserve the address of the reserve
     * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise*
     */
    "enableBorrowingOnReserve(address,bool)"(
      _reserve: string,
      _stableBorrowRateEnabled: boolean,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    disableBorrowingOnReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disables borrowing on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableBorrowingOnReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    enableReserveAsCollateral(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "enableReserveAsCollateral(address,uint256,uint256,uint256)"(
      _reserve: string,
      _baseLTVasCollateral: BigNumberish,
      _liquidationThreshold: BigNumberish,
      _liquidationBonus: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    disableReserveAsCollateral(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disables a reserve to be used as collateral
     * @param _reserve the address of the reserve*
     */
    "disableReserveAsCollateral(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    enableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * enable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "enableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    disableReserveStableBorrowRate(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * disable the stable borrow rate mode on a reserve
     * @param _reserve the address of the reserve*
     */
    "disableReserveStableBorrowRate(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    activateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * activates a reserve
     * @param _reserve the address of the reserve*
     */
    "activateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    deactivateReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * deactivates a reserve
     * @param _reserve the address of the reserve*
     */
    "deactivateReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    freezeReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to freeze the reserve. A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.
     * @param _reserve the address of the reserve*
     */
    "freezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    unfreezeReserve(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.
     * @param _reserve the address of the reserve*
     */
    "unfreezeReserve(address)"(
      _reserve: string,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    setReserveBaseLTVasCollateral(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the loan to value of a reserve
     * @param _ltv the new loan to value*
     * @param _reserve the address of the reserve
     */
    "setReserveBaseLTVasCollateral(address,uint256)"(
      _reserve: string,
      _ltv: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    setReserveLiquidationThreshold(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the liquidation threshold of a reserve
     * @param _reserve the address of the reserve
     * @param _threshold the new liquidation threshold*
     */
    "setReserveLiquidationThreshold(address,uint256)"(
      _reserve: string,
      _threshold: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    setReserveLiquidationBonus(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the liquidation bonus of a reserve
     * @param _bonus the new liquidation bonus*
     * @param _reserve the address of the reserve
     */
    "setReserveLiquidationBonus(address,uint256)"(
      _reserve: string,
      _bonus: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    setReserveDecimals(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;

    /**
     * allows the configurator to update the reserve decimals
     * @param _decimals the decimals of the reserve*
     * @param _reserve the address of the reserve
     */
    "setReserveDecimals(address,uint256)"(
      _reserve: string,
      _decimals: BigNumberish,
      overrides?: Overrides
    ): Promise<PopulatedTransaction>;
  };
}
